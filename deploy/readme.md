# Documentación acerca del despligue___Antes de seguir la guía, asegúrese de tener instalado docker ydocker-compose: https://docs.docker.com/engine/install/ubuntu/.## Tabla de contenido:- [Introducción](#introducción)  - [Componentes del frontend](#componentes-del-frontend)  - [Componentes del backend](#componentes-del-backend)- [Dockers del proyecto](#dockers-del-proyecto)  - [Docker de Base de Datos](#docker-de-base-de-datos)  - [Docker Nginx (Frontend)](#docker-nginx-(frontend))  - [Dockers Java (Eureka y Gateway)](#dockers-java-(eureka-y-gateway))  - [Dockers Python (Backend)](#dockers-python-(backend))- [Ubicación del código fuente](#ubicación-del-código-fuente)  - [Ubicación Frontend](#ubicacion-frontend)  - [Ubicación Eureka y Gateway](#ubicacion-eureka-y-gateway)  - [Ubicación Backend](#ubicación-backend)  - [Ubicación File](#ubicación-file)- [Archivos conf de Nginx](#archivos-conf-de-nginx)  - [Nginx iniciador](#nginx-iniciador)  - [Nginx del frontend](#nginx-del-frontend)  - [Nginx del balanceador de carga (Balancing)](#nginx-del-balanceador-de-carga-(balancing))- [Creación y administración de dockers](#creación-y-administración-de-dockers)## Introducción___Joinus está conformada de un frontend realizado en Angular, y una serie de microservicios construidos en Django. En detalle encontramos los siguientescomponentes y sus respectivos dockers:## Componentes del frontend<p align="center"><img src="images/componentes_frontend.png"/><i>Figura 1. Componentes del frontend.<br>Fuente: Elaboración propia</i></p>## Componentes del backend<p align="center"><img src="images/componentes_backend.png"/><i>Figura 2. Componentes del backend.<br>Fuente: Elaboración propia</i></p>## Dockers del proyecto___Todo los archivos necesarios para el despliegue del proyecto están organizadosen 2 directorios, uno para el código fuente de cada proyecto y un segundodirectorio donde se aloja los archivos necesarios para el despliegue. En elservidor de Ingeniería de Sistemas donde se desplegó la aplicación se crearonestos dos directorios.      código fuente: /var2/dockers-studentsprojects/joinus      archivos de despligue: /var2/dockers-studentsprojects-deploy/joinusSe sugiere conservar esta misma separación para despliegue local.El proyecto se despliega en dockers creados en el servidor de Ingeniería deSistemas, para esto se usa la herramienta `Docker Compose` la cual se trata deun archivo `YAML` que organiza los dockers que se ejecutaran asignando a cadauno de ellos un nombre; la imagen que usaran de DockerHub; el directorio detrabajo `working_dir` que será el inicial cuando ingresemos al docker; losvolumenes para crear un espejo de los datos externos que se usaran dentro deldocker; y por último, pero no menos importante se encuentra los puertos: queindican que puerto externo (puerto físico) será su equivalente en el interiordel docker (puerto virtual).A continuación se explica como estan compuestos los diferentes dockers delproyecto.### Docker de Base de DatosPara este caso la base de datos a subir será de `Mongo`, así se define el dockerpara ella:    mongo:        container_name: joinus_mongo        image: mongo        environment:            - MONGO_INITDB_DATABASE=<nombre_base_de_datos>            - MONGO_INITDB_ROOT_USERNAME=<usuario>            - MONGO_INITDB_ROOT_PASSWORD=<clave>        volumes:               - type: bind            source: /var2/dockers-studentsprojects/joinus/data/db            target: /data/db        ports:            - 27017:27017Aquí podemos encontrar los parametros que se mencionaron anteriormente, seobserva que la `image` base de este docker es `mongo`. Tambien se agreganvariables de entorno como son el nombre de la base de datos, el usuario root ysu clave.Los volumenes usan dos parámetros importantes: `source`, que indica eldirectorio físico que queremos reflejar en el interior del docker, el cual seráubicado en la dirección de `target`.El puerto virtual por el cual se desplegara será el `27017`, para acceder a estedesde el exterior se hace por el puerto físico `27017`; este es el puerto pordefecto para mongo.### Docker Nginx (Frontend)Así se define el docker de frontend:      frontend:       container_name: joinus_frontend       image: nginx:1.17.1-alpine       working_dir: /usr/local/app       volumes:         - type: bind           source: /var2/dockers-studentsprojects/joinus/my-nginx-frontend.conf           target: /etc/nginx/conf.d/default.conf         - type: bind           source: /var2/dockers-studentsprojects/joinus/nginx           target: /usr/share/nginx/html       ports:         - 8088:80Aquí tambien se puede observar que la imagen base de este docker es `nginx` ensu versión `1.17.1`, la palabra clave `alpine` quiere decir que es una versiónligera.### Dockers Java (Eureka y Gateway)Para el caso de los dockers que se basan en una imagen Java, se tiene el deeureka cómo ejemplo:      eureka:          container_name: joinus_eureka          image: openjdk:12          working_dir: /code          ports:            - 8090:8090          volumes:            - type: bind              source: /var2/dockers-studentsprojects/joinus/java/eureka              target: /code          command: java -jar target/eureka-0.0.1-SNAPSHOT.jarEs muy parecido al anterior solo con dos diferencias, la imagen es openjdk porestar basado en Java, también se observa una línea `command`, esta ejecuta elcomando especificado una vez el docker es creado, para este caso se ejecuta eljar de eureka para ejecutar el servicio. Más adelante se muestran los pasos paragenerar este Jar en caso de no encontrarlo.### Dockers Python (Backend)El caso de los dockers basados en python es algo similar:      institution:       container_name: joinus_institution       image: python:3.8       working_dir: /code       ports:         - 8091:8091       volumes:         - type: bind           source: /var2/dockers-studentsprojects/joinus/python/institution           target: /code       command: bash -c "         pip install -r requirements.txt &&         python3 manage.py runserver 0.0.0.0:8091         "La imagen base es `python:3.8` y se realizan dos comandos al iniciar el docker:el primero es para instalar las librerías en archivo derequerimientos `requeriments.txt`; y el segundo ejecuta la aplicación y ladespliega en el puerto `8091`.      file:       container_name: joinus_file       image: python:3.8       working_dir: /code       ports:         - 8096:8096       volumes:         - type: bind           source: /var2/dockers-studentsprojects/joinus/python/file           target: /code         - type: bind           source: /var2/dockers-studentsprojects/joinus/files           target: /tesis-asn       command: bash -c "         pip install -r requirements.txt &&         python3 manage.py runserver 0.0.0.0:8096         "El resto de dockers de python son similares, pero se resalta la definición deldocker file debido a que hay algo a tener en cuenta en él. Observe el segundovolumen, en el parámetro `source` se indica la ruta física donde se hara elrespaldo de los archivos que los usuarios suban a la plataforma, ya sea foto deperfil, o de una publicación, etc; y en el parámetro `target` se indica la rutavirtual (dentro del docker).## Ubicación del código fuente___Antes de desplegar los dockers en el servidor primero debemos guardar allí elcódigo fuente, jars o archivos estáticos de cada proyecto. En el servidor deIngeniería de sistemas todo el código fuente quedo almacenado en laruta: `/var2/dockers-studentsprojects/joinus/`, allí se hizo una carpeta paracada lenguaje: java, python y también para el servidor web nginx que despliegael frontend, se recomienda tener los mismos directorios en su directorio decódigo fuente.Las carpeta donde guarde el código fuente de cada lenguaje deberian tener lasiguiente estructura:- java- files- nginx- pythonEn realidad puede nombrarla a su gusto, lo importante es que los tenga en cuentaen las rutas de los volumenes en docker-compose.yml.### Ubicación FrontendEl docker `frontend` al estar construido sobre nginx no necesita de todo elcódigo fuente para desplegarse, solo usa los archivos estáticos generados en elbuild del proyecto. Para generarlos puede hacer el siguiente comando en la raízdel proyecto frontend:      ng build --prodCon este comando se generan los archivos estáticos en lacarpeta `dist/tesis-asn`, todo esos archivos dentro de ella debe alojarlos en lacarpeta donde esté guardando el código fuente del frontend, si sigue lasindicaciones aquí debería ser en la carpeta `nginx`, para el despliegue deJoinus se guardó en la carpeta `/var2/dockers-studentsprojects/joinus/nginx`cómo lo puede confirmar en el segundo parámetro `source` del docker frontend.El parámetro `--prod` indica a la terminal que debera usar las urls del ambientede producción, las cuales están guardadas en elarchivo: `src/environments/environment.prod.ts` del proyecto del frontend.Siguiendo la estructura de directorios inicial (omitiendo algunos archivos en laimagen):   <p align="center">      <img src="images/directorio_nginx.png"/>   </p>   <p align="center"><i>Figura 3. Directorio Nginx.<br>   Fuente: Elaboración propia</i></p>### Ubicación Eureka y GatewayPara estos dos dockers que estan basados en Java es necesario obtener el Jar decada uno el cual esta en la carpeta target de cada uno de estos dos proyectos,si no los encuentra o desea actualizarlos puede hacerlo en la sección maven conla opción `install`, así en la raíz del proyecto se creara la carpeta `target` ydentro de ella encontrara un archivo con extensión `.jar`, copie este archivo enla carpeta de su preferencia donde esté alojando todo el código fuente.Siguiendo la estructura de directorios inicial:   <p align="center">   <img src="images/directorios_java.png"/>   </p>   <p align="center"><i>Figura 4. Directectorios Java.<br>   Fuente: Elaboración propia</i></p>### Ubicación BackendPara estos dockers el proceso es más largo pero no por complejidad, sino porcantidad, hay más proyectos de este lenguaje, ocho (8) en total. El proceso essimple, en la carpeta que eligió para guardar el código python, clone o guardeel código fuente de cada proyecto y ya esta; si, asi de sencillo.Siguiendo la estructura de directorios inicial:   <p align="center">   <img src="images/directorio_python.png"/>   </p>   <p align="center"><i>Figura 5. Directectorios Python.<br>   Fuente: Elaboración propia</i></p>### Ubicación FilePara el docker de file aparte de clonar el código fuente de este proyecto cómose explicó `Dockers en Python`, se debe crear un directorio para almacenar ahílos archivos que los usuarios suban en la aplicación. Se puede escoger cualquierdirectorio, pero tenga presente que debe coincidir con la ruta del segundoparámetro source de los volumenes del docker `file`, que para elarchivo `docker-compose.yml` es: `/var2/dockers-studentsprojects/joinus/files`.Si siguió los pasos anteriores la estructura de directorios debería verse asídesde la capa más alta:   <p align="center">   <img src="images/organización_general.png"/>   </p>   <p align="center"><i>Figura 6. Organización general de directorios.<br>   Fuente: Elaboración propia</i></p>## Archivos conf de Nginx___Notará que en la raíz de este proyecto se encuentran tres (3) archivos conextensión `.conf`:1. my-nginx-init.conf2. my-nginx-frontend.conf3. my-nginx-balancing.conf### Nginx iniciadorEl archivo `my-nginx-init.conf` es el archivo de configuración del nginxinicial, ya sea si lo observa en el servidor de Ingeniería de sistemas o en suservidor de aplicación local. Siempre hay un Nginx en su servidor o computadorque inicia todo, allí debería guardar las `locations` que tiene este archivo.Entre ellas puede observar la location para el frontend `/joinus`; para elbalanceador de carga que simula un servidor remoto `/asn_balancing`; y la mismalocation pero para aceptar peticiones de websocket `/asn_balancing_socket` usadaen el micro servicio de notification y chat. Es de aclarar que elcampo `proxy_pass` lo debe editar con la ip privada de su computadora o suservidor.### Nginx del frontendEl archivo `my-nginx-frontend.conf` es corto y sirve para que al acceder a lalocation `/joinus` del archivo `my-nginx-init.conf`este se ubique en la carpeta donde esta almacena el código estatico delfrontend, el cual esta en `/usr/share/nginx/html` dentro del docker delfrontend. El contenido del archivo `my-nginx-frontend.conf` debe ir en elarchivo .conf del nginx de su docker `frontend`.### Nginx del balanceador de carga (Balancing)El archivo `my-nginx-balancing.conf` es muy importante pues aquí se da acceso alos microservicios de eureka y apigateway, necesarios para permitir el consumode todos los servicios de Python. También permite la comunicación con loswebsockets expuestos por los micro servicios Notification y Chat. Estaslocations deben ir en la configuración del Nginx en el docker `balancing`, conla dirección ip privada de su servidor o computador.Estos dos últimos archivos `my-nginx-frontend.conf` y `my-nginx-balancing.conf`deben ir en la raíz del directorio donde alojó el código fuente.Siguiendo la estructura de directorios inicial:   <p align="center">   <img src="images/archivos_nginx_conf.png"/>   </p>   <p align="center"><i>Figura 7. Archivos Nginx.<br>   Fuente: Elaboración propia</i></p>## Creación y administración de dockers___Una vez realizadas las anteriores configuraciones, es decir preparado eldirectorio que contiene todo el código fuente y configurados el Ngnix local oNginx inicial, cómo desee llamarlo, entonces se puede iniciar con la creación delos dockers.Hay tres archivos en la raíz de este proyecto que serán usados para este fin.El archivo `rebuild.sh` nos ayuda a construir los dockers que esten definidos enel archivo docker-compose.yml, para este caso esté último archivo debe estar almismo nivel de carpetas que el archivo .sh.Los archivos `start.sh` y `stop.sh` sirven para iniciar y detener los dockersrespectivamente.Estos tres archivos deben ir en un directorio definido para contener archivos dedespliegue, para este proyecto se nombró `deploy` y dentro del servidor deIngeniería de sistemas se encuentra en la siguiente ruta:      /var2/dockers-studentsprojects-deploy/joinusSiguiendo el despliegue local el directorio se encuentra aquí:   <p align="center">   <img src="images/directorio_deploy.png"/>   </p>   <p align="center"><i>Figura 8. Directorio deploy.<br>   Fuente: Elaboración propia</i></p>El archivo ``docker-compose.yml`` también debe ir en este directorio.Ejecute el archivo `rebuild.sh` los dockers iniciaran a crearse, y dentro deunos minutos Joinus se mostrara en la location que usted le haya colocado en elNginx inicial.                